---
date: 2019-11-05
title: Python Sequence
categories: 编程
tags: Python
---

## 序列

- 序列是一种数据存储方式，用来存储一系列的数据。在内存中，序列就是一块用来存放多个连续值的内存空间。序列中存储的是对象的地址，而不是对象的值，同时序列本身也是一个对象。Python中常用的序列结构有：字符串，列表，元组，集合。

<!-- more -->

## 字符串

#### 基本特点：

- 字符串的本质是字符序列。Python的字符串是不可变的，我们无法对原字符串做任何修改，但是可以将字符串的一部分复制到新创建的字符串，达到“看起来修改”的效果。

- Python不支持单字符类型，单字符也是作为一个字符串使用的

  

#### 字符串编码：

- Python3 支持Unicode，可以表示世界上任何书面语言的字符，Python3 的字符默认就是16位Unicode编码，ASCII码是Unicode编码的子集。

- 使用`ord()`可以把字符转换为对应的Unicode码，使用`chr()`可以把十进制数字转换为对应的字符。

#### 引号创建字符串：

- 可通过单引号或双引号创建字符串，根据情况使用两种引号。
- 连续三个单(双)引号，可以创建多行字符串。

#### 空字符串和len() 函数：

- Python允许空字符串的存在，不包含任何字符且长度为0，例如`c=‘’`
- len()用于计算字符串有多少字符

#### 转义字符：

- 使用`\+特殊字符`实现换行，回车，退格，制表等

-  `\续行符` `\\反斜杠` `\'单引号` `\"双引号` (和C相似)

#### 字符串操作：

- 拼接：可以使用+将多个字符串拼接起来，如`”aa“+”bb“+”cc“`，形成一个新字符串（新对象），如果+两边类型不同，会输出异常。因为使用+会生成新字符串对象，所以更推荐使用join()函数，因为此函数在拼接前会计算所有字符串长度，然后再逐一拷贝，仅新建一次对象。
- 复制：使用*实现复制，比如`“–” * 3`
- 不换行打印：调用print时会自动打印换行符，通过`end=“字符串”`进行改变。

```python
print("rapt",end=' ')
print("azure",end='##')
```
- 从控制台读取字符串：使用`input()`从控制台读取键盘输入的内容。

- `str()`实现数字转型字符串：比如`str(3.14e2)`>>>`314.0` ,调用`print()`函数时，解释器自动调用量str()将非字符串的对象转成了字符串。

- 使用[]提取字符：字符串的本质是字符序列，可以在[]里指定偏移量(索引)来提取该位置的单个字符，可以进行反向搜索。

  从左到右：`0` -> `len(str)-1`          从右到左：`-len(str)` <- `-1 `

- `replace()`实现字符串“替换”：字符串“不可变”，替换只能通过创建新字符串对象，原来的变量指向新字符串来实现。比如`a=a.replace(‘c’,‘a’)`

- `slice()`实现字符串切片：提取子字符串，格式`[start:end:step]`

  ```python
  Python 3.7.4 (default, Oct  4 2019, 06:57:26) 
  [GCC 9.2.0] on linux
  
  >>> a = "abcdefghijklmn"
  >>> a[2]
  'c'
  >>> a[1:5:1]
  'bcde'
  >>> a[1:5]
  'bcde'
  >>> a[1:5:2]
  'bd'
  >>> a[:]
  'abcdefghijklmn'
  >>> a[2:]
  'cdefghijklmn'
  >>> a[:2]
  'ab'
  >>> a[-3:]
  'lmn'
  >>> a[-8:-3]
  'ghijk'
  >>> a[::-1]
  'nmlkjihgfedcba'
  >>> a[2:400]
  'cdefghijklmn'
  ```

- `split()`分割和`join()`合并：split可以基于指定分隔符将字符串分割成多个子字符串（存储到列表中），如果不指定分隔符，默认使用空白字符(制表，换行，空格)。`join()`作用相反，用于合并一系列子字符串。

```python
>>> a = "2B or not 2B"
>>> a.split()
['2B', 'or', 'not', '2B']
>>> a.split('2B')
['', ' or not ', '']
>>> a =["2B","or","not","2B"]
>>> "*".join(a)
'2B*or*not*2B'
>>> " ".join(a)
'2B or not 2B'
```

- 一个小测试：使用join与+拼接字符串的不同效率

  ```python
  import time
  a = ""
  time01 = time.time()
  for i in range(1000000):
      a += "hit"    #创建1000000个对象
  time02 = time.time()
  print(time02-time01)
  
  time03 = time.time()
  li = []           #只有一个对象
  for i in range(1000000):
      li.append("hit")
  a = "".join(li)
  time04 = time.time()
  print(time04-time03)
  
  #0.16577386856079102
  #0.11212515830993652
  ```

#### 字符串驻留机制和字符串比较：

- 字符串驻留：仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串驻留池中。Python支持字符串驻留机制，对于符合标识符规则(字母，下划线，数字)的字符串会启用字符串驻留机制。

```python
>>> a = "abd_22"
>>> b = "abd_22"
>>> a is b
True  # 同一个对象
>>> c = "dd#"
>>> d = "dd#"
>>> c is d
False
```

- 成员操作符：`in/not in`判断某个子字符串是否存在字符串中

  ```python
  >>> a = "23333"
  >>> "2" in a
  True
  ```

#### 字符串常用方法：

- 查找：

```python
>>> a = "this is a simple test"
>>> len(a)
21
>>> a.startswith("this")
True
>>> a.endswith("est")
True
>>> a.find(" ")
4
>>> a.rfind('s')
19   
>>> a.count("s")
4       #计数出现次数
>>> a.isalnum()
False   #是否全是字母和数字
```

- 去除首尾信息：


```python
>>> a = "#this is a test#"
>>> a.strip("#")
'this is a test'
>>> "*h*i*t*".rstrip("*")
'*h*i*t'  #去掉了右边的*
>>> "       hit     ".strip()
'hit'
```

- 大小写转换：以下都产生了新字符串


```python
>>> a = 'hit wh'
>>> a.capitalize()
'Hit wh'
>>> a.title()
'Hit Wh'
>>> a.upper()
'HIT WH'
>>> a.swapcase()
'HIT WH'  #所有字母大小写转换
```

- 格式排版：


```python
>>> a = 'HIT'
>>> a.center(10)
'   HIT    '
>>> a.center(9,'#')
'###HIT###'
>>> a.ljust(10,'#')
'HIT#######'
```

- 其他方法：
  - `isalnum()`是否为字母或数字
  - `isalpha()`检测字符串是否只由字母组成(含汉字) ->Unicode
  - `isdigit()`检测是否只由数字组成
  - `isspace()`检测是否为空白字符
  - `isupper()`是否为大写字母
  - `islower()`是否为小写字母

#### 字符串格式化

- `format()`基本用法：可以通过{索引}或者{参数名}直接映射参数值。

  ```python
  >>> a = "my name is: {0}. my age is: {1}"
  >>> a.format("raptazure",18)
  'my name is: raptazure. my age is: 18'
  >>> a.format("r",2)
  'my name is: r. my age is: 2'
  >>> b = "my name is {0} and {0} is good."
  >>> b.format("r")
  'my name is r and r is good.'
  >>> c = "name:{name}  age:{age}"
  >>> c.format(age = 19, name = 'r')
  'name:r  age:19'
  ```
- 填充与对齐：^ < > 分别是居中，左对齐，右对齐，后面带宽度。:后带填充的字符，只能是一个字符，不指定默认用空格填充。

```python
>>> "{:*>8}".format('2333')
'****2333'
>>> "I am {0},I like {1:*^8}".format("R","233")
'I am R,I like **233***'
```

#### 数字格式化：

- ```python
  >>> a = "I am {0} and my number is {1:.2f}"
  >>> a.format("R",23333.5566)
  'I am R and my number is 23333.56'
  # {:,} 三位用，隔开
  # {:.2e} 指数记法
  # {:.2%} 百分比格式
  # {:+.2f} 带符号保留小数点后两位
  # {:x<4d} 数字补x，填充右边，宽度为4
  # {:10d} 默认右对齐，宽度为10
  ```

#### 可变字符串：

- Python中的字符串属于不可变对象，不可原地修改，修改其中的值只能创建新字符串对象。如果确实需要原地修改字符串，可用`io.StringIO`对象或`array`模块。

```python
>>> import io
>>> s = "rapt"
>>> sio = io.StringIO(s)
>>> sio
<_io.StringIO object at 0x7f5e56094870>
>>> sio.getvalue()
'rapt'
>>> sio.seek(3)
3
>>> sio.write('9')
1
>>> sio.getvalue()
'rap9'
```

## 列表

#### 基本概念：

- 列表是用于存储任意数目，任意类型的数据集合。列表中元素可以各不相同，可为任意类型。
- 常用方法：

```python
list.append(x)  #将元素x加到list尾部
list.extend(aList) #将列表aList所有元素加到list尾部
list.insert(index,x) #在list指定位置index插入元素x
list.remove(x)  #在list中删除首次出现的指定元素x
list.pop(index) #删除并返回list指定index处元素，默认最后一个元素
list.clear()  #删除列表所有元素，并不是删除列表对象
list.index(x)  #返回第一个x的索引位置，若不存在x则抛出异常
list.count(x)  #返回指定元素x在list中出现次数
len(list)   #返回列表list中包含元素个数
list.reverse() #所有元素原地翻转
list.sort()  #所有元素原地排序
list.copy()  #返回列表对象的浅拷贝
```

- Python的列表大小可变，根据需要随时增加或者缩小
- 字符串和列表都是序列类型，一个字符串是一个字符序列，一个列表是任何元素的序列，字符串方法很多在列表中同样适用。

#### 列表的创建：

- 基本语法[]创建：

```python
>>> a = []
>>> a
[]
>>> a = [233,23333,'r']
>>> a
[233, 23333, 'r']
>>> a.append(90)
>>> a
[233, 23333, 'r', 90]
# 
```

- `list()`可以将任何可迭代数据转化为列表：

  ```python
  >>> a = list()
  # range()创建列表：range(start,end,step)
  >>> a = list(range(10))
  >>> a
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  >>> a = list(range(15,3,-2))
  >>> a
  [15, 13, 11, 9, 7, 5]
  >>> a = list('rapt')
  >>> a
  ['r', 'a', 'p', 't']
  ```
  
- 推导式生成列表：

  ```python
  # 循环创建多个元素
  >>> a = [x*2 for x in range(5)]
  >>> a
  [0, 2, 4, 6, 8]
  # 通过if过滤元素
  >>> a = [x*2 for x in range(100) if x%9 == 0]
  >>> a
  [0, 18, 36, 54, 72, 90, 108, 126, 144, 162, 180, 198]
  ```
  
#### 列表元素的增加与删除

-  列表增删元素时，会自动进行内存管理。由于在列表中间操作会涉及列表元素的大量移动，效率较低。所以一般只在列表尾部添删元素，可以提高列表的操作效率。

  ```python
  # append()原地修改列表对象，真正在尾部添加新元素，速度最快
  >>> a = [20,10]
  >>> a.append(99)
  >>> a
  [20, 10, 99]
  # +创建新列表对象，将原列表与新列表对象元素依次复制到新列表
  # 对象中，涉及较多复制操作，对大量元素不建议使用
  >>> a = [233,666]
  >>> id(a)
  140040216615824
  >>> a = a + [3]
  >>> id(a)
  140040216502752
  >>> a
  [233, 666, 3]
  # extend()将目标列表所有元素添加到尾部，不创建新对象
  >>> a = [233,2333]
  >>> a.extend([233333,233333])
  >>> a
  [233, 2333, 233333, 233333]
  # insert()将指定元素插入到列表对象任意位置，插入位置后的所# 有元素移动。类似发生这种移动的函数还有remove(),pop(),
  # del，涉及大量元素时效率低
  >>> a = ['r',2]
  >>> a.insert(1,233)
  >>> a
  ['r', 233, 2]
  ```
  
- 使用乘法可以扩展(重复)列表生成新列表。
  
  ```python
  # del可以删除指定位置元素
  >>> a = [233,2333]
  >>> del a[1]
  >>> a
  [233]
  # pop()删除并返回指定位置元素，默认位置为最后一个元素
  >>> a = [1,2,3,4,'r']
  >>> a.pop()
  'r'
  >>> a
  [1, 2, 3, 4]
  >>> a.pop(1)
  2
  >>> a
  [1, 3, 4]
  # remove()删除首次出现的指定元素
  >>> a = [1,2,555,233,6]
  >>> a.remove(555)
  >>> a
  [1, 2, 233, 6]
  ```
  
#### 列表元素的访问和计数：

- 通过索引直接访问元素。

- `index(value,start,end)`获得指定元素在列表中首次出现的索引，start和end指定了搜索的范围，默认从头到尾。

```python
>>> a = [1,2,3,'r']
>>> a.index('r')
3
>>> a.index(2,1)
1
```

- `count()`获取指定元素在列表中出现次数。

- 成员资格判断：可以用`count()`或者`in`。

  
#### 列表切片操作：

- 和字符串类似，切片适用于列表，元组，字符串等

```python
>>> a = [10,20,30,40,50,60]
>>> a[:]
[10, 20, 30, 40, 50, 60]
>>> a[1:3:2]
[20]
>>> a[1::2]
[20, 40, 60]
>>> a[1:]
[20, 30, 40, 50, 60]
>>> a[:2]
[10, 20]
>>> a[-5:-3]
[20, 30]
>>> a[::-1]
[60, 50, 40, 30, 20, 10]
# 切片包含头不包含尾
```

#### 列表遍历：

```python
for obj in listObj:
    print(obj)
    
# ps:以下操作无法实现列表元素复制
list1 = [1,2,3'r']
list2 = list1
# 只是将list2也指向了列表对象，也就是说list1和list2持有地址值相
# 同，列表对象本身的元素并没有复制。
```

#### 列表排序：

- 直接修改原列表：

  ```python
  >>> a = [20,25,23,233]
  >>> a.sort()
  >>> a
  [20, 23, 25, 233]
  >>> a.sort(reverse = True)
  >>> a
  [233, 25, 23, 20]
  >>> import random
  >>> random.shuffle(a)
  >>> a
  [20, 233, 25, 23]
  ```

- 新建列表的排序：

```python
>>> a = [1,2,20,3,233]
>>> id(a)
140399227782160
>>> a = sorted(a)
>>> a
[1, 2, 3, 20, 233]
>>> id(a)
140399201146032
>>> a = sorted(a,reverse = True)
>>> a
[233, 20, 3, 2, 1]
```

- `reversed()`返回迭代器：也支持逆序排列，不对原列表做任何修改，只是返回一个逆序排列的迭代器对象。

  ```python
  >>> a = [20,10,30,40]
  >>> c = reversed(a)
  >>> c
  <list_reverseiterator object at 0x7fb13c84dd50>
  >>> list(c)
  [40, 30, 10, 20]
  # 迭代器指针从后向前移动，迭代对象在第一次时遍历结束
  >>> list(c)
  []
  ```

#### 其他内置函数：

- `max()` `min()`用于返回列表中最大/小值
- `sum()`对数值型所有元素求和

#### 多维列表：
- 二维列表可以存储表格的数据，列表的元素也可以是列表

  ```python
  # IDLE
  >>> a = [
  	['r',18],
  	['a',17],
  	['p',16],
  	['t',15]
  	]
  >>> a[0]
  ['r', 18]
  >>> a[0][0]
  'r'
  # VS Code
  a = [
  	['r',18],
  	['a',17],
  	['p',16],
  	['t',15]
  	]
  for i in range(4):
      for j in range(2):
          print(a[i][j],end = '\t')
      print()
      # 打印完一行后换行
  
  ‘’‘
  r	18	
  a	17	
  p	16	
  t	15
  ’‘’
  ```
## 元组 Tuple
#### 基本概念：

- 元组属于不可变序列，不可修改元组中的元素。元组支持：

  索引访问，切片操作，连接操作，成员关系操作，比较运算操作，计数操作比如`len() sum() max() min()`

#### 创建：
- 通过`()`, 小括号可以省略

  ```python
  >>> a = (1,2,3)
  >>> a
  (1, 2, 3)
  >>> type(a)
  <class 'tuple'>
  >>> a = 1,
  >>> type(a)
  <class 'tuple'>
  # 注意单个元素的情况
  >>> a = (1)
  >>> type(a)
  <class 'int'>
  ```
  
- 通过`tuple(可迭代的对象)` 

  ```python
  >>> b = tuple()
  >>> b
  ()
  >>> b = tuple(range(3))
  >>> b
  (0, 1, 2)
  >>> b = tuple([2,3,4])
  >>> b
  (2, 3, 4)
  >>> b = tuple('r')
  >>> b
  ('r',)
  >>> del b  #删除
  # tuple()可接受列表，字符串，其他序列类型，迭代器->元组
  # list()可接受元组，字符串，其他序列类型，迭代器->列表
  ```

#### 元素访问与计数：

- 元组元素不可修改 -  immutable

- 访问方法与列表相同，不过仍然返回元组对象。

- 列表关于排序的方法list.sorted()是修改原列表对象，元组没有该方法，如果要对元组排序，只能使用内置函数sorted(tupleObj)，并生成新的列表对象。

- `zip()`将多个列表对应位置元素组合为元组，并返回这个zip对象。

  ```python
  >>> a = (9,6,7,8)
  >>> a[0]
  9
  >>> sorted(a)
  [6, 7, 8, 9]
  >>> b = [1,5,2,3]
  >>> c = [233,2333]
  >>> d = [555,666]
  >>> e = zip(b,c,d)
  >>> e
  <zip object at 0x7fc3c2f0e1e0>
  >>> list(e)
  [(1, 233, 555), (5, 2333, 666)]
  ```
#### 生成器推导式创建元组：

- 形式上与列表推导式类似，只是使用小括号。列表推导式生成列表，生成器推导式生成的不是列表也不是元组，而是一个生成器对象。

- 可以通过生成器对象转化为列表或元组，也可使用生成器对象的`__next__()`方法进行遍历，或直接作为迭代器对象使用。不管以什么方式使用，元素访问(指针移动)结束后，如果需要重新访问其中元素则需重新创建该生成器对象。

  ```python
  >>> s = (x*2 for x in range(5))
  >>> s
  <generator object <genexpr> at 0x7fc3c37d9c50>
  >>> tuple(s)
  (0, 2, 4, 6, 8)
  >>> list(s)
  # 只能访问一次元素
  []
  >>> s = (x*2 for x in range(5))
  >>> s.__next__()
  0
  >>> s.__next__()
  2
  >>> s.__next__()
  4
  ```
#### 总结：

- 元组核心特点：不可变序列
- 元组访问和处理速度快于列表
- 与整数和字符串一样，元组可作字典的键，列表不能作为字典的键使用。

## 字典

#### 基本概念：

- 字典是“键值对”的无序可变序列，字典中每个元素都是一个“键值对”，包含：“键对象”和“值对象”。可以通过“键对象”实现快速获取，删除，更新对应的“值对象”。

- 列表中通过下标数字找到对应对象。字典中通过“键对象”找到对应的“值对象”。“键”是任意的不可变数据，比如：整数，浮点数，字符串，元组，但是列表，字典，集合这些可变对象不可作为“键”。

- “键”不可重复，“值”可以是任意数据，可重复。

- 定义方式：`a = {'name':'rapt', 'age':18}`

#### 字典的创建：

- 可通过`{}` `dict()`创建字典对象

  ```python
  >>> a = dict(name = 'rapt', age = 18)
  >>> a
  {'name': 'rapt', 'age': 18}
  >>> b = dict([('name','rapt'), ('age',18)])
  >>> b
  {'name': 'rapt', 'age': 18}
  # 创建空字典  c = {}    d = dict()
  ```
  
- `zip()`创建字典对象

  ```python
  >>> k = ['name', 'age', 'job']
  >>> v = ['rapt', '18', 'student']
  >>> d = dict(zip(k,v))
  >>> d
  {'name': 'rapt', 'age': '18', 'job': 'student'}
  ```
  
- 通过fromkeys创建值为空的字典

  ```python
  >>> a = dict.fromkeys(['name', 'age', 'job'])
  >>> a
  {'name': None, 'age': None, 'job': None}
  ```

#### 字典元素的访问：

- 通过[键]获得“值”

  ```python
  >>> a = {'name':'rapt','age':18,'job':'student'}
  >>> a['name']
  'rapt'
  >>> a['age']
  18
  ```
  
- 通过`get()`方法获得“值”，若指定键不存在则返回None，也可设定指定键不存在时默认返回的对象。

  ```python
  >>> a = {'name':'rapt', 'age':18, 'job':'student'}
  >>> a.get('name')
  'rapt'
  >>> print(a.get('sex'))
  None
  >>> a.get('sex','Not Exist')
  'Not Exist'
  # 列出所有键值对
  >>> a.items()
  dict_items([('name', 'rapt'), ('age', 18), ('job', 'student')])
  # 列出所有键
  >>> a.keys()
  dict_keys(['name', 'age', 'job'])
  # 列出所有值
  >>> a.values()
  dict_values(['rapt', 18, 'student'])
  # 键值对个数
  >>> len(a)
  3
  # 检测key是否在字典中
  >>> "name" in a
  True
  ```
#### 字典元素添加，修改，删除：

- 给字典新增“键值对”，若“键”已存在，则覆盖旧的键值对;如果“键”不存在，则新增“键值对”。

```python
>>> a = {'name':'rapt','age':18,'job':'student'}
>>> a['address']='HITwh'
>>> a['age']=19
>>> a
{'name': 'rapt', 'age': 19, 'job': 'student', 'address': 'HITwh'}
```
- 使用`update()`将新字典中所有键值对全部添加到旧字典对象上，若key有重复，则直接覆盖。

  ```python
  >>> b = {"name":'raptazure',"sex":"male"}
  >>> a.update(b)
  >>> a
  {'name': 'raptazure', 'age': 19, 'job': 'student', 'address': 'HITwh', 'sex': 'male'}
  ```
  
- 字典中元素的删除，可以使用`del()`方法，或者`clear()`删除所有键值对，`pop()`删除指定键值对，并返回对应的“值对象”
  
  ```python
    >>> a ={"name":'rapt',"age":18,'job':'student'}
    >>> del(a['job'])
    >>> a
    {'name': 'rapt', 'age': 18}
    >>> b = a.pop('age')
    >>> b
    18
    >>> a
    {'name': 'rapt'}
   >>> a.clear()
  >>> a
  {} 
  ```
  
- `popitem()`随机删除和返回该键值对，字典是“无序可变序列”，因此没有第一个元素和最后一个元素的概念。popitem弹出随机的项，因为字典中并没有有关顺序的概念。若想一个接一个地移除并处理项，这个方法很有效（不用首先获取键的列表）。

  ```python
  >>> a  = {"name":'rapt','age':18,'job':'student'}
  >>> a.popitem()
  ('job', 'student')
  >>> a
  {'name': 'rapt', 'age': 18}
  >>> a.popitem()
  ('age', 18)
  >>> a
  {'name': 'rapt'}
  ```

#### 序列解包：
- 序列解包可用于元组，列表，字典，方便对多个变量赋值。

  ```python
  >>> x,y,z = (20,30,233)
  >>> x
  20
  >>> y
  30
  >>> z
  233
  >>> (a,b,c) = (9,8,23)
  >>> a
  9
  >>> [a,b,c] = [23,233,2333]
  >>> a
  23
  >>> b
  233
  ```
  
- 序列解包用于字典时，默认对key进行操作，如果需对键值对进行操作，则需使用`items()`；如果需要对值进行操作，则需用`values()`

  ```python
  >>> s = {"name":'rapt','age':18,'job':'student'}
  >>> a,b,c = s
  >>> a
  'name'
  >>> b
  'age'
  >>> a,b,c = s.items()
  >>> a
  ('name', 'rapt')
  >>> a,b,c = s.values()
  >>> c
  'student'
  ```

#### 表格数据使用字典和列表存储：
| name  |  age  |   job   |   city   |
| :---: | :---: | :-----: | :------: |
| rapt  |  18   | student | Beijing  |
| azure |  19   |   boy   | Shanghai |
| happy |   1   |  girl   | Shenzhen |

```python
r1 = {'name':'rapt','age':18,'job':'student','city':'Beijing'}
r2 = {'name':'azure','age':19,'job':'boy','city':'Sahnghai'}
r3 = {'name':'happy','age':1,'job':'girl','city':'Shenzhen'}
table = [r1,r2,r3]
#获取第二行的job
print(table[1].get("job"))
print('')
#打印表中所有job & age
for i in range(len(table)):
	print(table[i].get('job'),table[i].get('age'))
```

#### 字典核心底层原理：

- 字典对象的核心是散列表，散列表是一个稀疏数组（总是有空白元素的数组），数组的每个单词叫做bucket，每个bucket有两个部分：一个是键对象的引用，一个是值对象的引用。由于所有bucket结构和大小一致，可以通过偏移量来读取指定bucket。

  |   0   | key1  | value1 |
  | :---: | :---: | :----: |
  |   1   |       |        |
  |   2   | key2  | value2 |
  |   3   |       |        |
  |   4   |       |        |
  |   5   | key4  | value4 |
  
- 将一个键值对放到字典的底层过程：假设字典a对象创建完后，数组长度为8，要把“name” = “rapt”这个键值对放到字典对象a中，首先计算键`'name'`的散列值`hash()`，由于数组长度为8，可以拿计算出的散列值最右边3位数字作为偏移量(若长度为32则6位6位取)，即100，十进制数字为4，查看偏移量4对应的bucket值是否为空，若空则放入键值对，若不空则向左取次右边3位作为偏移量，即->100->111，111十进制为7，再看偏移量为7的bucket是否为空，直到找到空的bucket将键值对放进去。

  ```python
  >>> a = {}
  >>> a['name'] = 'rapt'
  >>> bin(hash('name'))
  '-0b10101110010111000010011110111010110011000011011001110111100100'
  ```
  
  Python根据散列表的拥挤程度扩容。如果数组有2/3已满，则会自动扩容以创建更大数组，将原内容拷贝到新数组中。
  
- 根据key查找“键值对”的底层过程：当调用`a.get('name')`，就是根据key`'name'`找到键值对，从而找到值对象`'rapt'` 。首先仍要计算`‘name'`对象的散列值，和存储的底层流程算法一致，也是依次取散列值的不同位置的数字。假设数组长度为8，拿出计算出的散列值的最右边3位数字作为偏移量，即100，十进制数字为4，查看偏移量4对应的bucket值是否为空，若空则返回None，若不空则将这个bucket的键对象计算对应散列值，与上次计算得出的散列值比较，如果相等则将对应值对象返回，如果不相等则再依次取其他几位数字，重新计算偏移量。依次取完后仍没有找到则返回None。
  
#### 总结：

- 键必须可散列
  - 数字，字符串，元组都可散列
  - 自定义对象需支持以下三点：
    1. 支持`hash()`函数
    2. 支持通过`__eq__()`方法检测相等性
    3. 若a==b为真，则`hash(a)=hash(b)`也为真
  - 字典在内存中开销巨大，典型的空间换时间
- key查询速度很快
  - 往字典中添加新建可能导致扩容，导致散列表中键的次序变化。因此不要在遍历字典的同时修改字典。

## 集合

#### 基本概念：

- 集合无序可变，元素不可重复，实际上底层是字典实现，集合所有元素都是字典中的键对象，因此是不能重复的。

#### 集合的创建和删除：

- 使用{}创建集合对象，并用`add()`方法添加元素。

  ```python
  >>> a = {3,5,7}
  >>> a
  {3, 5, 7}
  >>> a.add(9)
  >>> a
  {9, 3, 5, 7}
  ```
  
- 使用`set()`将列表，元组等可迭代对象转成集合。如果原数据中存在重复数据，则只保留一个。
  
```python
  >>> a = ['a','b','c','b']
>>> b = set(a)
  >>> b
  {'a', 'b', 'c'}
```

#### 集合相关操作：

```python
# 删除元素
>>> a = {233,666,555}
>>> a.remove(555)
>>> a
{233, 666}
>>> a.clear()
>>> a
set()
>>> a = {1,3,'rapt'}
>>> b = {1,2,'rapt'}
>>> a|b  #并集
{1, 2, 3, 'rapt'}
>>> a&b  #交集
{'rapt', 1}
>>> a-b  #差集
{3}
>>> a.union(b) #并集
{1, 2, 3, 'rapt'}
>>> a.intersection(b) #交集
{'rapt', 1}
>>> a.difference(b)  #差集
{3}
```



  

  

